// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package usecases

import (
	"context"
	"sync"

	"github.com/PiskarevSA/go-advanced/internal/entities"
)

// Ensure that mockStorage does implement storage.
// If this is not the case, regenerate this file with mockery.
var _ storage = &mockStorage{}

// mockStorage is a mock implementation of storage.
//
//	func TestSomethingThatUsesstorage(t *testing.T) {
//
//		// make and configure a mocked storage
//		mockedstorage := &mockStorage{
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			GetMetricFunc: func(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
//				panic("mock out the GetMetric method")
//			},
//			GetMetricsByTypesFunc: func(ctx context.Context, gauge map[entities.MetricName]entities.Gauge, counter map[entities.MetricName]entities.Counter) error {
//				panic("mock out the GetMetricsByTypes method")
//			},
//			PingFunc: func(ctx context.Context) error {
//				panic("mock out the Ping method")
//			},
//			UpdateMetricFunc: func(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
//				panic("mock out the UpdateMetric method")
//			},
//			UpdateMetricsFunc: func(ctx context.Context, metrics []entities.Metric) ([]entities.Metric, error) {
//				panic("mock out the UpdateMetrics method")
//			},
//		}
//
//		// use mockedstorage in code that requires storage
//		// and then make assertions.
//
//	}
type mockStorage struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// GetMetricFunc mocks the GetMetric method.
	GetMetricFunc func(ctx context.Context, metric entities.Metric) (*entities.Metric, error)

	// GetMetricsByTypesFunc mocks the GetMetricsByTypes method.
	GetMetricsByTypesFunc func(ctx context.Context, gauge map[entities.MetricName]entities.Gauge, counter map[entities.MetricName]entities.Counter) error

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) error

	// UpdateMetricFunc mocks the UpdateMetric method.
	UpdateMetricFunc func(ctx context.Context, metric entities.Metric) (*entities.Metric, error)

	// UpdateMetricsFunc mocks the UpdateMetrics method.
	UpdateMetricsFunc func(ctx context.Context, metrics []entities.Metric) ([]entities.Metric, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetMetric holds details about calls to the GetMetric method.
		GetMetric []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metric is the metric argument value.
			Metric entities.Metric
		}
		// GetMetricsByTypes holds details about calls to the GetMetricsByTypes method.
		GetMetricsByTypes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Gauge is the gauge argument value.
			Gauge map[entities.MetricName]entities.Gauge
			// Counter is the counter argument value.
			Counter map[entities.MetricName]entities.Counter
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpdateMetric holds details about calls to the UpdateMetric method.
		UpdateMetric []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metric is the metric argument value.
			Metric entities.Metric
		}
		// UpdateMetrics holds details about calls to the UpdateMetrics method.
		UpdateMetrics []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metrics is the metrics argument value.
			Metrics []entities.Metric
		}
	}
	lockClose             sync.RWMutex
	lockGetMetric         sync.RWMutex
	lockGetMetricsByTypes sync.RWMutex
	lockPing              sync.RWMutex
	lockUpdateMetric      sync.RWMutex
	lockUpdateMetrics     sync.RWMutex
}

// Close calls CloseFunc.
func (mock *mockStorage) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("mockStorage.CloseFunc: method is nil but storage.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedstorage.CloseCalls())
func (mock *mockStorage) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetMetric calls GetMetricFunc.
func (mock *mockStorage) GetMetric(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
	if mock.GetMetricFunc == nil {
		panic("mockStorage.GetMetricFunc: method is nil but storage.GetMetric was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Metric entities.Metric
	}{
		Ctx:    ctx,
		Metric: metric,
	}
	mock.lockGetMetric.Lock()
	mock.calls.GetMetric = append(mock.calls.GetMetric, callInfo)
	mock.lockGetMetric.Unlock()
	return mock.GetMetricFunc(ctx, metric)
}

// GetMetricCalls gets all the calls that were made to GetMetric.
// Check the length with:
//
//	len(mockedstorage.GetMetricCalls())
func (mock *mockStorage) GetMetricCalls() []struct {
	Ctx    context.Context
	Metric entities.Metric
} {
	var calls []struct {
		Ctx    context.Context
		Metric entities.Metric
	}
	mock.lockGetMetric.RLock()
	calls = mock.calls.GetMetric
	mock.lockGetMetric.RUnlock()
	return calls
}

// GetMetricsByTypes calls GetMetricsByTypesFunc.
func (mock *mockStorage) GetMetricsByTypes(ctx context.Context, gauge map[entities.MetricName]entities.Gauge, counter map[entities.MetricName]entities.Counter) error {
	if mock.GetMetricsByTypesFunc == nil {
		panic("mockStorage.GetMetricsByTypesFunc: method is nil but storage.GetMetricsByTypes was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Gauge   map[entities.MetricName]entities.Gauge
		Counter map[entities.MetricName]entities.Counter
	}{
		Ctx:     ctx,
		Gauge:   gauge,
		Counter: counter,
	}
	mock.lockGetMetricsByTypes.Lock()
	mock.calls.GetMetricsByTypes = append(mock.calls.GetMetricsByTypes, callInfo)
	mock.lockGetMetricsByTypes.Unlock()
	return mock.GetMetricsByTypesFunc(ctx, gauge, counter)
}

// GetMetricsByTypesCalls gets all the calls that were made to GetMetricsByTypes.
// Check the length with:
//
//	len(mockedstorage.GetMetricsByTypesCalls())
func (mock *mockStorage) GetMetricsByTypesCalls() []struct {
	Ctx     context.Context
	Gauge   map[entities.MetricName]entities.Gauge
	Counter map[entities.MetricName]entities.Counter
} {
	var calls []struct {
		Ctx     context.Context
		Gauge   map[entities.MetricName]entities.Gauge
		Counter map[entities.MetricName]entities.Counter
	}
	mock.lockGetMetricsByTypes.RLock()
	calls = mock.calls.GetMetricsByTypes
	mock.lockGetMetricsByTypes.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *mockStorage) Ping(ctx context.Context) error {
	if mock.PingFunc == nil {
		panic("mockStorage.PingFunc: method is nil but storage.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedstorage.PingCalls())
func (mock *mockStorage) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// UpdateMetric calls UpdateMetricFunc.
func (mock *mockStorage) UpdateMetric(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
	if mock.UpdateMetricFunc == nil {
		panic("mockStorage.UpdateMetricFunc: method is nil but storage.UpdateMetric was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Metric entities.Metric
	}{
		Ctx:    ctx,
		Metric: metric,
	}
	mock.lockUpdateMetric.Lock()
	mock.calls.UpdateMetric = append(mock.calls.UpdateMetric, callInfo)
	mock.lockUpdateMetric.Unlock()
	return mock.UpdateMetricFunc(ctx, metric)
}

// UpdateMetricCalls gets all the calls that were made to UpdateMetric.
// Check the length with:
//
//	len(mockedstorage.UpdateMetricCalls())
func (mock *mockStorage) UpdateMetricCalls() []struct {
	Ctx    context.Context
	Metric entities.Metric
} {
	var calls []struct {
		Ctx    context.Context
		Metric entities.Metric
	}
	mock.lockUpdateMetric.RLock()
	calls = mock.calls.UpdateMetric
	mock.lockUpdateMetric.RUnlock()
	return calls
}

// UpdateMetrics calls UpdateMetricsFunc.
func (mock *mockStorage) UpdateMetrics(ctx context.Context, metrics []entities.Metric) ([]entities.Metric, error) {
	if mock.UpdateMetricsFunc == nil {
		panic("mockStorage.UpdateMetricsFunc: method is nil but storage.UpdateMetrics was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Metrics []entities.Metric
	}{
		Ctx:     ctx,
		Metrics: metrics,
	}
	mock.lockUpdateMetrics.Lock()
	mock.calls.UpdateMetrics = append(mock.calls.UpdateMetrics, callInfo)
	mock.lockUpdateMetrics.Unlock()
	return mock.UpdateMetricsFunc(ctx, metrics)
}

// UpdateMetricsCalls gets all the calls that were made to UpdateMetrics.
// Check the length with:
//
//	len(mockedstorage.UpdateMetricsCalls())
func (mock *mockStorage) UpdateMetricsCalls() []struct {
	Ctx     context.Context
	Metrics []entities.Metric
} {
	var calls []struct {
		Ctx     context.Context
		Metrics []entities.Metric
	}
	mock.lockUpdateMetrics.RLock()
	calls = mock.calls.UpdateMetrics
	mock.lockUpdateMetrics.RUnlock()
	return calls
}

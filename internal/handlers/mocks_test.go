// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package handlers

import (
	"context"
	"sync"

	"github.com/PiskarevSA/go-advanced/internal/entities"
)

// Ensure that mockMetricsUsecase does implement metricsUsecase.
// If this is not the case, regenerate this file with mockery.
var _ metricsUsecase = &mockMetricsUsecase{}

// mockMetricsUsecase is a mock implementation of metricsUsecase.
//
//	func TestSomethingThatUsesmetricsUsecase(t *testing.T) {
//
//		// make and configure a mocked metricsUsecase
//		mockedmetricsUsecase := &mockMetricsUsecase{
//			DumpIteratorFunc: func(ctx context.Context) (func() (type_ string, name string, value string, exists bool), error) {
//				panic("mock out the DumpIterator method")
//			},
//			GetMetricFunc: func(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
//				panic("mock out the GetMetric method")
//			},
//			PingFunc: func(ctx context.Context) error {
//				panic("mock out the Ping method")
//			},
//			UpdateMetricFunc: func(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
//				panic("mock out the UpdateMetric method")
//			},
//			UpdateMetricsFunc: func(ctx context.Context, metrics []entities.Metric) ([]entities.Metric, error) {
//				panic("mock out the UpdateMetrics method")
//			},
//		}
//
//		// use mockedmetricsUsecase in code that requires metricsUsecase
//		// and then make assertions.
//
//	}
type mockMetricsUsecase struct {
	// DumpIteratorFunc mocks the DumpIterator method.
	DumpIteratorFunc func(ctx context.Context) (func() (type_ string, name string, value string, exists bool), error)

	// GetMetricFunc mocks the GetMetric method.
	GetMetricFunc func(ctx context.Context, metric entities.Metric) (*entities.Metric, error)

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) error

	// UpdateMetricFunc mocks the UpdateMetric method.
	UpdateMetricFunc func(ctx context.Context, metric entities.Metric) (*entities.Metric, error)

	// UpdateMetricsFunc mocks the UpdateMetrics method.
	UpdateMetricsFunc func(ctx context.Context, metrics []entities.Metric) ([]entities.Metric, error)

	// calls tracks calls to the methods.
	calls struct {
		// DumpIterator holds details about calls to the DumpIterator method.
		DumpIterator []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetMetric holds details about calls to the GetMetric method.
		GetMetric []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metric is the metric argument value.
			Metric entities.Metric
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpdateMetric holds details about calls to the UpdateMetric method.
		UpdateMetric []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metric is the metric argument value.
			Metric entities.Metric
		}
		// UpdateMetrics holds details about calls to the UpdateMetrics method.
		UpdateMetrics []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metrics is the metrics argument value.
			Metrics []entities.Metric
		}
	}
	lockDumpIterator  sync.RWMutex
	lockGetMetric     sync.RWMutex
	lockPing          sync.RWMutex
	lockUpdateMetric  sync.RWMutex
	lockUpdateMetrics sync.RWMutex
}

// DumpIterator calls DumpIteratorFunc.
func (mock *mockMetricsUsecase) DumpIterator(ctx context.Context) (func() (type_ string, name string, value string, exists bool), error) {
	if mock.DumpIteratorFunc == nil {
		panic("mockMetricsUsecase.DumpIteratorFunc: method is nil but metricsUsecase.DumpIterator was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDumpIterator.Lock()
	mock.calls.DumpIterator = append(mock.calls.DumpIterator, callInfo)
	mock.lockDumpIterator.Unlock()
	return mock.DumpIteratorFunc(ctx)
}

// DumpIteratorCalls gets all the calls that were made to DumpIterator.
// Check the length with:
//
//	len(mockedmetricsUsecase.DumpIteratorCalls())
func (mock *mockMetricsUsecase) DumpIteratorCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDumpIterator.RLock()
	calls = mock.calls.DumpIterator
	mock.lockDumpIterator.RUnlock()
	return calls
}

// GetMetric calls GetMetricFunc.
func (mock *mockMetricsUsecase) GetMetric(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
	if mock.GetMetricFunc == nil {
		panic("mockMetricsUsecase.GetMetricFunc: method is nil but metricsUsecase.GetMetric was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Metric entities.Metric
	}{
		Ctx:    ctx,
		Metric: metric,
	}
	mock.lockGetMetric.Lock()
	mock.calls.GetMetric = append(mock.calls.GetMetric, callInfo)
	mock.lockGetMetric.Unlock()
	return mock.GetMetricFunc(ctx, metric)
}

// GetMetricCalls gets all the calls that were made to GetMetric.
// Check the length with:
//
//	len(mockedmetricsUsecase.GetMetricCalls())
func (mock *mockMetricsUsecase) GetMetricCalls() []struct {
	Ctx    context.Context
	Metric entities.Metric
} {
	var calls []struct {
		Ctx    context.Context
		Metric entities.Metric
	}
	mock.lockGetMetric.RLock()
	calls = mock.calls.GetMetric
	mock.lockGetMetric.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *mockMetricsUsecase) Ping(ctx context.Context) error {
	if mock.PingFunc == nil {
		panic("mockMetricsUsecase.PingFunc: method is nil but metricsUsecase.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedmetricsUsecase.PingCalls())
func (mock *mockMetricsUsecase) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// UpdateMetric calls UpdateMetricFunc.
func (mock *mockMetricsUsecase) UpdateMetric(ctx context.Context, metric entities.Metric) (*entities.Metric, error) {
	if mock.UpdateMetricFunc == nil {
		panic("mockMetricsUsecase.UpdateMetricFunc: method is nil but metricsUsecase.UpdateMetric was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Metric entities.Metric
	}{
		Ctx:    ctx,
		Metric: metric,
	}
	mock.lockUpdateMetric.Lock()
	mock.calls.UpdateMetric = append(mock.calls.UpdateMetric, callInfo)
	mock.lockUpdateMetric.Unlock()
	return mock.UpdateMetricFunc(ctx, metric)
}

// UpdateMetricCalls gets all the calls that were made to UpdateMetric.
// Check the length with:
//
//	len(mockedmetricsUsecase.UpdateMetricCalls())
func (mock *mockMetricsUsecase) UpdateMetricCalls() []struct {
	Ctx    context.Context
	Metric entities.Metric
} {
	var calls []struct {
		Ctx    context.Context
		Metric entities.Metric
	}
	mock.lockUpdateMetric.RLock()
	calls = mock.calls.UpdateMetric
	mock.lockUpdateMetric.RUnlock()
	return calls
}

// UpdateMetrics calls UpdateMetricsFunc.
func (mock *mockMetricsUsecase) UpdateMetrics(ctx context.Context, metrics []entities.Metric) ([]entities.Metric, error) {
	if mock.UpdateMetricsFunc == nil {
		panic("mockMetricsUsecase.UpdateMetricsFunc: method is nil but metricsUsecase.UpdateMetrics was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Metrics []entities.Metric
	}{
		Ctx:     ctx,
		Metrics: metrics,
	}
	mock.lockUpdateMetrics.Lock()
	mock.calls.UpdateMetrics = append(mock.calls.UpdateMetrics, callInfo)
	mock.lockUpdateMetrics.Unlock()
	return mock.UpdateMetricsFunc(ctx, metrics)
}

// UpdateMetricsCalls gets all the calls that were made to UpdateMetrics.
// Check the length with:
//
//	len(mockedmetricsUsecase.UpdateMetricsCalls())
func (mock *mockMetricsUsecase) UpdateMetricsCalls() []struct {
	Ctx     context.Context
	Metrics []entities.Metric
} {
	var calls []struct {
		Ctx     context.Context
		Metrics []entities.Metric
	}
	mock.lockUpdateMetrics.RLock()
	calls = mock.calls.UpdateMetrics
	mock.lockUpdateMetrics.RUnlock()
	return calls
}
